---
title: "Rust 🦀 and WebAssembly 🕸を読む"
emoji: "🕸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["wasm"]
published: false
---

# 概要

[Rust 🦀 and WebAssembly 🕸](https://rustwasm.github.io/docs/book/)を読みつつ感想などを書きます。
必要に応じてコードなども書いていくつもりです。

# Introduction

最初にだれのための本かを記載しています。
Rust で WebAssembly のコンパイルに興味を持つすべての人向け。
Rust, JavaScript, HTML, CSS を前提知識として要求しています。
ただし、それらのエキスパートでなくてもよい、としています。

チュートリアルの読み方について、初めから終わりまで順に読むように書かれているそうです。
辞書的に使うのではなく、順番に読みましょう、ということですね。

# Why Rust and WebAssembly

なぜ Rust と WebAssembly を使うの化、というモチベーションについて書かれています。

-   JavaScript の Web アプリケーションでは安定したパフォーマンスを達成し、維持するのに課題がある。
    JavaScript の動的型システムとガベージコレクションによる停止は役に立たない。
    Rust は低レベルの制御と安定したパフォーマンスを得られる。非決定的なガベージコレクションによる停止から解放される。
-   ネットワークを通じてダウンロードされる.wasm のコードサイズは非常に重要。
    Rust は処理系を持たないため、ガベージコレクタのようなサイズの肥大化を防ぐことができる。
    実際に使う関数だけのサイズになる
-   既存のコードベースを捨てる必要はない。パフォーマンスが必要となる JavaScript の関数を Rust に置き換えるところから始められるし、そこでやめることもできる。
-   Rust と WebAssembly は既存の JavaScript のツールに統合される。ECMAScript モジュールをサポートしており、npm や Webpack を使い続けることができる。
-   Rust は開発者が期待するモダンなアメニティを備えている。
    -   cargo による強力なパッケージ管理
    -   表現力豊かな（そしてゼロコストの）抽象化
    -   そしてコミュニティ。

# Background and Concepts

## What is WebAssembly?

WebAssembly とは何か？

WebAssembly(wasm)とはシンプルな機械モデルであり、膨大な仕様を持つ実行形式である。
ポータブルで、コンパクトで、ネイティブの、あるいはネイティブに近い速度が出るように設計されている。

プログラミング言語としては、WebAssemblyは同じ構造を表し、異なる方式で動く二つのフォーマットからなる。

1. `.wat`テキストフォーマット（"WebAssembly Text") はS式を使っており、SchemeやClojureのようなLispファミリーの言語と幾分似ている。
2. `.wasm`バイナリフォーマットはより低レベルで、wasm仮想マシンによって直接実行されることを想定している。概念的にはELFやMach-Oに似ている。

`wat`による階乗関数は以下のようになる。

```wasm
(module
    (func $fac (param f64) (result f64)
        local.get 0
        f64.const 1
        f64.lt
        if (result f64)
            f64.const 1
        else
            local.get 0
            local.get 0
            f64.const 1
            f64.sub
            call $fac
            f64.mul
        end)
    (export "fac" (func $fac))
)
```

[wat2wasmデモ](https://webassembly.github.io/wabt/demo/wat2wasm/)で、上記のコードを試すこともできる。

### Linear Memory

WebAssemblyはとてもシンプルなメモリモデルを持っている。wasmモジュールは一つの "線形メモリ"にアクセスする。
これはバイトのフラットな配列である。
このメモリはページサイズ（64K）の倍数で増えていく。

### WebAssemblyはWebのためだけのもの？

現在はJavaScriptとWebのコミュニティが一般的に注目を集めているが、wasmはホスト環境について何の想定もしていない。
wasmは"ポータブルな実行形式"になり、将来的には様々なコンテキストで使われることになるだろう。
しかし、今のところ、wasmはJavaScriptに最も関係が深い。JSにはNodeもWebも含まれる。

# Tutorial: Conway’s Game of Life

このチュートリアルはRustとJavaScriptの基礎的な経験がある人向け。
さらに、どうやってRust, WebAssembly, JavaScriptを一緒に使うのかを学びたい人向け

## 何をこれから学ぶのか？

- WebAssemblyのコンパイルのためのRustツールチェインのセットアップ方法
- Rust, WebAssembly, JavaScript, HTML, CSSから、複数の言語を使ったプログラムを開発するためのワークフロー
- RustとWebAssembly,そしてJavaScriptの強味を最大限に生かしたAPI設計の仕方
- RustでコンパイルされたWebAssemblyモジュールのデバッグの仕方
- RustとWebAssemblyのプログラムの時間を計測して、高速化する手法
- RustとWebAssemblyのプログラムのサイズを計測して、`.wasm`バイナリをより小さくし、ネットワーク経由でのダウンロードを高速化する手法

## セットアップ

### Rust toolchain

省略

### `wasm-pack`

`wasm-pack`はRustで生成されたWebAssemblyのビルド、テスト、公開をワンストップで行うツール。

インストール方法は以下([参照URL: wasm-pack公式](https://rustwasm.github.io/wasm-pack/installer/))

```sh
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
```

### `cargo-generate`

既存のGitリポジトリをテンプレートとして使うことで、新しいRustプロジェクトを素早く立ち上げるのに役立ちます。
すでにプロジェクトがある場合は必要ないかも。

このインストールの際に、以下のようなエラー。

```sh
error: failed to run custom build command for `openssl-sys v0.9.60`
```

[参照URL: Qiita](https://qiita.com/nacika_ins/items/465e89a7b3fbeb373605)
に従って、libssl-devのインストールとOpensslの環境変数を指定したら通った。

```sh
$ sudo apt update
$ sudo apt install libssl-dev
```
```sh
# ~/.bashrc
export OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu/
export OPENSSL_INCLUDE_DIR=/usr/include/openssl/
```

### `npm`

JavaScriptのパッケージマネージャ。割愛。

## Hello, World!

いよいよハロワ。

### テンプレリポジトリの作成

```sh
$ cargo generate --git https://github.com/rustwasm/wasm-pack-template
```

名前を聞かれるので、チュートリアル通り`wasm-game-of-life`とした。

### Rustupのターゲットの追加

Wasm用のコンパイル・ターゲットをインストールする。
このターゲット指定によって、Rustのソースコードが`.wasm`にコンパイルされる。

```sh
$ rustup target add wasm32-unknown-unknown
```

テンプレリポジトリに最初から依存関係として指定されている `wasm-bindgen`は、JavaScriptのAPIをRustが生成するWasm用に生成するのに使う。

### ビルドの実行

`wasm-pack`を使ってビルドを実行する。

```sh
$ wasm-pack build
```

生成されるファイルは以下。

```sh
$ tree pkg/
pkg/
├── README.md
├── package.json
├── wasm_game_of_life.d.ts
├── wasm_game_of_life.js
├── wasm_game_of_life_bg.js
├── wasm_game_of_life_bg.wasm
└── wasm_game_of_life_bg.wasm.d.ts
```

#### `wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm`

`.wasm`ファイルはRustソースからRustコンパイラによって生成されたWebAssemblyのバイナリである。
これにはすべてのRust関数とデータのcompiled-to-wasmバージョンが含まれている。例えば、 `gree`関数がエクスポートされている。

#### `wasm-game-of-life/pkg/wasm_game_of_life_bg.js`

この`.js`ファイルは`wasm-bindgen`によって生成されており、RustにDOMとJavaScriptをインポートし、またWebAssemblyの優れたAPIをJavaScriptに対してエクスポートするためのJavaScriptのグルーコードが含まれている。
例えば、WebAssemblyモジュールからエクスポートされた`greet`関数をラップするJavaScriptの`greet`関数がある。
いま、このグルーはそれ以上のことは何もしない。しかし、wasmとJavaScriptの間でより面白い値をやり取りし始めると、それらの境界を越えて値を導く手助けとなる。

```js
// wasm_game_of_life_bg.js
import * as wasm from './wasm_game_of_life_bg.wasm';

const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
/**
*/
export function greet() {
    wasm.greet();
}

export const __wbg_alert_fbbeabc2309f67cb = function(arg0, arg1) {
    alert(getStringFromWasm0(arg0, arg1));
};

```

#### `wasm-game-of-life/pkg/wasm_game_of_life.d.ts`

この`.d.ts`ファイルは JavaScriptグルーのためのTypeScriptの型宣言を含んでいる。
TypeScriptを使う場合、型検査されたWebAssembly関数をコールすることができるし、IDEの自動補完やサジェストを受けることができる。
TypeScriptを使わない場合は、これらのファイルは無視してよい。

```ts
/* tslint:disable */
/* eslint-disable */
/**
*/
export function greet(): void
```

#### `wasm-game-of-life/pkg/package.json`

この`package.json`ファイルは生成されたJavaScriptとWebAssemblyパッケージについてのメタデータが含まれている。
これはnpmとJavaScriptバンドラが依存関係やパッケージ名、バージョンその他を決定するために使われる。
これはJavaScriptの周辺ツールとの統合に役立ち、またnpmに対してパッケージを公開することができる。

```json
{
  "name": "wasm-game-of-life",
  "collaborators": [
    "Umu999 <8ejrwawiq3xy@gmail.com>"
  ],
  "version": "0.1.0",
  "files": [
    "wasm_game_of_life_bg.wasm",
    "wasm_game_of_life.js",
    "wasm_game_of_life.d.ts"
  ],
  "module": "wasm_game_of_life.js",
  "types": "wasm_game_of_life.d.ts",
  "sideEffects": false
}
```

